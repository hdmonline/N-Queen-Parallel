\documentclass[twoside,12pt]{article}
\usepackage{amsmath,amsfonts,amsthm,fullpage}
%\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{float}
\usepackage{graphicx}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[vlined, ruled, boxed]{algorithm2e}
\title{CSE6220 High Performance Computing Spring 2019 \\
	Homework 2}
\author{Chong Ye (cye38)}

\begin{document}

\maketitle

\section{Preamble}
For question 3, I discussed with Dongmin Han and Yuanlai Zhou and we worked together to figure out the parallel solution. 


\section{Solutions}
\begin{enumerate}
\item
The parallel prefix algorithm can be used if the binary operation is associative.
\begin{enumerate}
	\item $ op(a,b)=2a+b $ \\
	since \[ op(op(a,b),c)=2(2a+b)+c=4a+2b+c \]
	\[ op(a,op(b,c))=2a+(2b+c)=2a+2b+c \]
	\[ \Rightarrow op(op(a,b),c) \neq op(a,op(b,c)) \]
	Thus $ op(a,b)=2a+b $ is not associative operation.Therefore, parallel prefix algorithm cannot be used in this binary operation.
	\item $ op(a,b)=\sqrt{a^2+b^2} $\\
	Since
	\[ op(op(a,b),c)=\sqrt{(\sqrt{a^2+b^2})^2+c^2}=\sqrt{a^2+b^2+c^2} \]
	\[ op(a,op(b,c))=\sqrt{a^2+(\sqrt{b^2+c^2})^2}=\sqrt{a^2+b^2+c^2} \]
	\[ \Rightarrow op(op(a,b),c)= op(a,op(b,c))\]
	Thus $ op(a,b)=\sqrt{a^2+b^2} $ is associative operation.Therefore, parallel prefix algorithm can be used in this binary operation.
\end{enumerate}

\setlength{\parindent}{1em}
\item The polynomial is:
\[ P(x)=a_{n-1}*x^{n-1}+a_{n-2}*x^{n-2}+......+a_2x^2+a_1x+a_0 \]
Using the Horner's law, the polynomial could be evaluated as:
\[ ((......(((a_{n-1}*x+a_{n-2})*x+a_{n-3})*x+a_{n-4})......)*x+a_1)*x+a_0 \]
Define:
\[ P_0=a_{n-1} \]
\[ P_i=P_{i-1}*x+a_{n-i-1} \]
Then
\[ P_{n-1}=a_{n-1}*x^{n-1}+a_{n-2}*x^{n-2}+......+a_2x^2+a_1x+a_0 \]
We have
\[ 
\begin{bmatrix}
P_i &1
\end{bmatrix} 
=
\begin{bmatrix}
P_{i-1} &1
\end{bmatrix}
\begin{bmatrix}
x &0\\
a_{n-i-1} &1
\end{bmatrix}\]
We can use parallel prefix algorithm and use multiplication as the operation.

\vspace{3mm}

\item $ x_0=a_0 $
\[ x_1=\frac{a_1}{a_0} \]
\[ x_2=\frac{a_0a_2}{a_1} \]
\[ x_3=\frac{a_1a_3}{a_0a_2} \]
\[ x_4=\frac{a_0a_2a_4}{a_1a_3} \]
thus we need to know $ a_0, a_0a_2, a_0a_2a_4...a_{2k},... $ and $ a_1, a_1a_3, a_1a_3a_5...a_{2k-1},... $. \\
We can implement parallel prefix algorithm with the multiplication as the operation. However, we do not need to do the first multiplication with adjacent processes. The algorithm is shown as below.

\begin{algorithm}[H]
	\caption{Parallel Prefix Algorithm}
	total\_multiplication $ \gets $ prefix\_multiplication $ \gets $ local\_number\\
	\For{$ j=1 $ to $ d-1 $}
	{
		$ rank' \gets rank\ XOR\ 2^{j} $\\
		send $ total\_multiplication $ to $ rank' $\\
		receive $ received\_multiplication $ from $ rank' $\\
		$ total\_multiplication \gets total\_multiplication \times received\_multiplication $\\
		\If{$ rank > rank' $}{
			$ prefix\_multiplication \gets prefix\_multiplication \times reveived\_multiplication $
		}
	}
	\If{$ rank < p - 1 $}{
		$ rank' \gets rank + 1 $\\
		send $ prefix\_multiplication $ to $ rank' $\\
	}
	\uIf{$ rank > 0 $}{
		$ rank'' \gets rank - 1 $\\
		receive $ received\_multiplication $ from $ rank'' $\\
		$ x_i = \frac{prefix\_multiplication}{received\_multiplication} $
	}
\end{algorithm}
After calculating the $ a_0, a_0a_2, a_0a_2a_4...a_{2k},... $ and $ a_1, a_1a_3, a_1a_3a_5...a_{2k-1},... $, then we can compute $ x_0, x_1, x_2,......,x_n $ shown in the above algorithm 1.

\item To assign the rank to element $ A[i] $ with label $ L[i] $, we need to know the number of elements whose label is smaller than $ L[i] $ and the elements whose label is $ L[i] $ however have lower index than $ A[i] $. \\
We can make an matrix $ B[i][j] $ with size $ n*k $. for element $ A[i] $, if  $ L[i]=m $, we let $ B[i][m]=1 $, otherwise, mark $ B[i][m]=0 $. Implement prefix sum algorithm on vectors $ B[i][:] $ with addition as the operation. Thus we have $ n $ vectors: 
\[ B[1], B[2],B[3],......,B[n]  \]
Let $ P[i] $ be the prefix sum and $ S $ be the total sum. Thus we have:
\[ P[i]=\sum_{j=1}^{i}B[j] \]
\[ T=\sum_{j=1}^{n}B[j] \]
The rank for element $ A[i] $ can be calculated as:
\[ R[i]=P[i][L[i]]+\sum_{j=1}^{L[i]-1}T[j] \] where
$ P[i][L[i]] $ is the $ L[i] $th element in vector $ P $, which is the number of elements with label $ L[i] $ but have lower index than  $ A[i] $. $ \sum_{j=1}^{L[i]-1}T[j] $ is the sum of the first $ L[i]-1 $th elements of vector $ T $, indicating the number of elements with smaller labels than  $ A[i] $.\\
Computing time:
\begin{enumerate}
	\item Time used for computing vector B: $ O(n/p) $
	\item Time used for prefix sum algorithm:
	 \[ Computaion time = O(\frac{n}{p}+\log p) \] 
	 \[ Communication time = O((\tau+\mu)log p) \]
	\item Time used for calculating ranks: $ O(n/p) $
\end{enumerate}
Therefore, the total running time is:
\[ O(\frac{n}{p}+(\tau+\mu)\log p) \]


\item To calculate the distance to the nearest 1 to the left side for each entry of $ A $ that is 0, we need to know the index of entry 0 and the index of the nearest 0, then the distance is the subtraction of the indexes. \\
Thus we could make another array $ B $ corresponding with array $ A $. 
\begin{enumerate}
	\item Make an array B with length n and element $ B[i]=i*A[i] $
	\item Implement parallel prefix algorithm with max operation. Prefix maximum $ P[i] $ represents the maximum element in array $ B $ prior to element $ B[i] $ (including $ B[i] $).
	\item Calculate the distance for the entry $ A[i] $ that is 0 as $ i-P[i] $.
\end{enumerate}
Running time:
\begin{enumerate}
	\item $ O(\frac{n}{p}) $
	\item 	 $Computaion time = O(\frac{n}{p}+\log p) $ \\
	$ Communication time = O((\tau+\mu)log p) $
	\item $ O(n/p) $
\end{enumerate}
Therefore, the total running time is:
\[ O(\frac{n}{p}+(\tau+\mu)\log p) \]

\end{enumerate}

     
\end{document}